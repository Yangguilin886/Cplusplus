class Solution {
public:
    TreeNode* dfs(ListNode* head,int left,int right)
    {
        if(left>right)return nullptr;
        int mid=(left+right)/2;
        int m=0;
        ListNode* prev=head;
        int k=mid;
        while(k--)
        {
            prev=prev->next;
        }
        TreeNode* cur=new TreeNode(prev->val);
        cur->left=dfs(head,left,mid-1);
        cur->right=dfs(head,mid+1,right);
        return cur;
    }
    TreeNode* sortedListToBST(ListNode* head) {
        int n=0;
        ListNode* cur=head;
        while(cur)
        {
            n++;
            cur=cur->next;
        }
        TreeNode* root=dfs(head,0,n-1);
        return root;
    }
};

//法二
class Solution {
public:
    TreeNode* dfs(vector<int>& nums,int left,int right)
    {
        if(left>right)
        {
            return nullptr;
        }
        int mid=(left+right)/2;
        TreeNode* cur=new TreeNode(nums[mid]);
        cur->left=dfs(nums,left,mid-1);
        cur->right=dfs(nums,mid+1,right);
        return cur;
    }
    TreeNode* sortedListToBST(ListNode* head) {
        vector<int> nums;
        ListNode* cur=head;
        while(cur)
        {
            nums.push_back(cur->val);
            cur=cur->next;
        }
        TreeNode* root=dfs(nums,0,nums.size()-1);
        return root;
    }
};